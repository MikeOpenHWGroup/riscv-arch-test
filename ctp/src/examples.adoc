
[appendix]
== Examples

This appendix gives examples of coverpoints and tests consistent with the test plan.  These examples are not the only way to satisfy the testplan.

=== Unprivileged example: `add`

Coverage is in I_coverage.svh:

[[f-add-covergroup]]
.`add` Covergroup
[source,verilog]
----
covergroup I_add_cg with function sample(ins_t ins);
    option.per_instance = 0;
    cp_asm_count : coverpoint ins.ins_str == "add"  iff (ins.trap == 0 )  {
        //Number of times instruction is executed
        bins count[]  = {1};
    }
    cp_rs1 : coverpoint ins.get_gpr_reg(ins.current.rs1)  iff (ins.trap == 0 )  {
        //RS1 register assignment
    }
    cp_rs2 : coverpoint ins.get_gpr_reg(ins.current.rs2)  iff (ins.trap == 0 )  {
        //RS2 register assignment
    }
    cp_rd : coverpoint ins.get_gpr_reg(ins.current.rd)  iff (ins.trap == 0 )  {
        //RD register assignment
    }
    cp_rs1_edges : coverpoint unsigned'(ins.current.rs1_val)  iff (ins.trap == 0 )  {
        `ifdef XLEN32
            bins zero  =    {0};
            bins one  =     {32'b00000000000000000000000000000001};
            bins two  =     {32'b00000000000000000000000000000010};
            bins min  =     {32'b10000000000000000000000000000000};
            bins minp1  =   {32'b10000000000000000000000000000001};
            bins max  =     {32'b01111111111111111111111111111111};
            bins maxm1  =   {32'b01111111111111111111111111111110};
            bins ones  =    {32'b11111111111111111111111111111111};
            bins onesm1  =  {32'b11111111111111111111111111111110};
            bins walkeodd = {32'b10101010101010101010101010101010};
            bins walkeven = {32'b01010101010101010101010101010101};
            wildcard bins random = {32'b01???????????????????????????010};
        `else
            bins zero  = {0};
            bins one      = {64'b0000000000000000000000000000000000000000000000000000000000000001};
            bins two      = {64'b0000000000000000000000000000000000000000000000000000000000000010};
            bins min      = {64'b1000000000000000000000000000000000000000000000000000000000000000};
            bins minp1    = {64'b1000000000000000000000000000000000000000000000000000000000000001};
            bins Wmax     = {64'b0000000000000000000000000000000011111111111111111111111111111111};
            bins Wmaxm1   = {64'b0000000000000000000000000000000011111111111111111111111111111110};
            bins Wmaxp1   = {64'b0000000000000000000000000000000100000000000000000000000000000000};
            bins Wmaxp2   = {64'b0000000000000000000000000000000100000000000000000000000000000001};
            bins max      = {64'b0111111111111111111111111111111111111111111111111111111111111111};
            bins maxm1    = {64'b0111111111111111111111111111111111111111111111111111111111111110};
            bins ones     = {64'b1111111111111111111111111111111111111111111111111111111111111111};
            bins onesm1   = {64'b1111111111111111111111111111111111111111111111111111111111111110};
            bins walkeodd = {64'b1010101010101010101010101010101010101010101010101010101010101010};
            bins walkeven = {64'b0101010101010101010101010101010101010101010101010101010101010101};
            wildcard bins random = {64'b01???????????????????????????????????????????????????????????010};
        `endif
    }
    cp_rs2_edges : coverpoint unsigned'(ins.current.rs2_val)  iff (ins.trap == 0 )  {
        `ifdef XLEN32
            bins zero  =    {0};
 ...
        `else
            bins zero  = {0};
            ...
        `endif
    }
    cr_rs1_rs2_edges : cross cp_rs1_edges,cp_rs2_edges  iff (ins.trap == 0 )  {
        //Cross coverage of RS1 edges and RS2 edges
    }
    cmp_rs1_rs2 : coverpoint ins.get_gpr_reg(ins.current.rs1)  iff (ins.current.rs1 == ins.current.rs2 & ins.trap == 0 )  {
        //Compare assignments of all registers
    }
    cmp_rd_rs1 : coverpoint ins.get_gpr_reg(ins.current.rd)  iff (ins.current.rd == ins.current.rs1 & ins.trap == 0 )  {
        //Compare assignments of all registers
    }
    cmp_rd_rs2 : coverpoint ins.get_gpr_reg(ins.current.rd)  iff (ins.current.rd == ins.current.rs2 & ins.trap == 0 )  {
        //Compare assignments of all registers
    }
    cmp_rd_rs1_rs2 : coverpoint ins.get_gpr_reg(ins.current.rd)  iff (ins.current.rd == ins.current.rs1 & ins.current.rd == ins.current.rs2 & ins.trap == 0 )  {
        //Compare assignments of all registers
    }
    cp_gpr_hazard_rw : coverpoint check_gpr_hazards(ins.hart, ins.issue)  iff (ins.trap == 0 )  {
        //GPR Hazard
        bins hazards[]  = {NO_HAZARD, RAW_HAZARD, WAW_HAZARD, WAR_HAZARD};
    }
endgroup
----

Corresponding RV32 tests are in tests/rv32/I/I-add.S.  Observe how the directed tests align with the coverpoints and bins.  Register numbers and values are randomized unless they are swept by the coverpoint. The RVTEST_SIGUPD macro compares the result against an expected signature produced by a reference model. When register 0 is used, it is loaded with a random value, but hardwired to 0, so the reference model will show that it behaves as 0.

[[f-add-tests]]
.`add` Tests
[source,asm]
----
# Testcase cp_rs1 (Test source rs1 = x0)
li x0, 0xb4e96718 # initialize rs1
li x24, 0xeaa512b3 # initialize rs2
add x25, x0, x24 # perform operation
RVTEST_SIGUPD(x3, x25)

# Testcase cp_rs1 (Test source rs1 = x1)
li x1, 0x81c4ef2a # initialize rs1
li x6, 0x917cfa69 # initialize rs2
add x7, x1, x6 # perform operation
RVTEST_SIGUPD(x3, x7)

...

# Testcase cp_rs1 (Test source rs1 = x31)
mv x21, x31 # switch signature pointer register to avoid conflict with test
li x31, 0x1508dd4e # initialize rs1
li x14, 0x830d07b0 # initialize rs2
add x11, x31, x14 # perform operation
RVTEST_SIGUPD(x21, x11)


# Testcase cp_rd (Test destination rd = x0)
li x19, 0x1d01c852 # initialize rs1
li x9, 0x1bfbf146 # initialize rs2
add x0, x19, x9 # perform operation
RVTEST_SIGUPD(x20, x0)

# Testcase cp_rd (Test destination rd = x1)
li x26, 0x1e3aafcf # initialize rs1
li x19, 0x986da37b # initialize rs2
add x1, x26, x19 # perform operation
RVTEST_SIGUPD(x20, x1)

...

# Testcase cr_rs1_rs2_edges (Test source rs1 = 0x0 rs2 = 0x0)
li x15, 0x00000000 # initialize rs1
li x5, 0x00000000 # initialize rs2
add x11, x15, x5 # perform operation
RVTEST_SIGUPD(x10, x11)

# Testcase cr_rs1_rs2_edges (Test source rs1 = 0x0 rs2 = 0x1)
li x1, 0x00000000 # initialize rs1
li x31, 0x00000001 # initialize rs2
add x20, x1, x31 # perform operation
RVTEST_SIGUPD(x10, x20)

# Testcase cr_rs1_rs2_edges (Test source rs1 = 0x0 rs2 = 0x2)
li x27, 0x00000000 # initialize rs1
li x3, 0x00000002 # initialize rs2
add x11, x27, x3 # perform operation
RVTEST_SIGUPD(x10, x11)

# Testcase cr_rs1_rs2_edges (Test source rs1 = 0x0 rs2 = 0x80000000)
li x8, 0x00000000 # initialize rs1
li x5, 0x80000000 # initialize rs2
add x16, x8, x5 # perform operation
RVTEST_SIGUPD(x10, x16)
----

=== Test case example: cr_rs1_rs2_edges bin with rs1 = 0x0, rs2 = 0x80000000

[source,asm]
----
# Testcase cr_rs1_rs2_edges (Test source rs1 = 0x0 rs2 = 0x80000000)
li x8, 0x00000000 # initialize rs1 in randomly selected register
li x5, 0x80000000 # initialize rs2 in randomly selected register
add x16, x8, x5 # perform operation, write randomly selected destination register
# load expected value of 0x800000000 into x20 from table pointed to by x10. Check x20 against x16 and report mismmatch
RVTEST_SIGUPD(x10, x16, x20)
----

`RVTEST_SIGUPD` macro:
[source,asm]
----
if (RVTEST_SELFCHECK) # check result against signature
    LREG x20, 0(x10)
    beq x16, x20, 1f
    ecall
    1f:
else # generate signature
    SREG x16, 0(x10)
    addi x10, x10, WORDSIZE
    nop
----
