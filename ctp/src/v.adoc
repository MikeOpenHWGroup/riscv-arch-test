
=== V Vector Extension

The vector coverpoints are intended to be flexible to support the full V extension, the Zve* embedded vector extensions, and arbitrary mixes of supported vector length (VLEN), element lengths (SEW~MIN~, ELEN), and floating-point precisions.

The vector extension is huge.  The testplan is partitioned into three unprivileged portions discussed here, and three privileged portions (ZicsrV, ExceptionsV, SsstrictV) discussed in XREF.

The full V extension supports all selected element widths SEW={8, 16, 32, 64}.  The vector coverage files and tests are organized by SEW.  Thus, a DUT could handle any contiguous subset of SEW from SEW~MIN~ to ELEN.  For example, a DUT with SEW~MIN~=16 and ELEN=32 would support SEW={16, 32}.

The tests detect VLMAX and set the vector length accordingly, up to some configurable maximum VLEN (default 4096 bits, although the vector extension theoretically supports up to 65536).  Therefore, there is no need for different test suites for different VLENs.

==== Vector File Organization

<<f-vector-organization>> summarizes the structure of the coverpoint and test files for the vector extension.  The unprivileged vector tests are organized by integer (Vx), load/store (Vls), and floating-point (Vf) types of instructions. Each applies to SEW=8, 16, 32, and/or 64. The ExceptionsV, ZicsrV, and SsstrictV privileged tests are described in section XREF.

The vector tests are organized by XLEN=32 and XLEN=64 because the scalar registers behavior differs by XLEN.  For example, vadd.vx with SEW=64 sign-extends XLEN=32 scalar registers but does not modify XLEN=64 scalar registers.  For a given XLEN, the vector tests are organized by type (Vx/Vls/Vf) and SEW (8/16/32/64).  Each directory contains a .S file for every vector instruction of that type footnote:[Certain instructions are omitted if not supported for a given SEW.  For example, widening add vwadd.vv is not supported for SEW=64, and vrgatherei16.v is not supported for SEW=8.].  Vector load/store instructions run with any SEW but also specify EEW as part of the instruction name.  For example, vle8.v and vle16.v can both be executed in either SEW=8 or SEW=16, and the EMUL behavior is different between these modes.  Therefore, all the load/store variants are included in all of Vls{8/16/32/64}.

[NOTE]
====
Vx and Vf are separated because certain extensions such as Zve64x do not support
floating-point.  Vls could be lumped with Vx, but the coverpoints are so different that
it is easier to define the tests separately, and facilitates just running integer vs. load/store tests during development.
====

[[f-vector-organization]]
.Vector Organization
----
fcov
    unpriv
        Vx8_coverage.svh
        Vx16_coverage.svh
        Vx32_coverage.svh
        Vx64_coverage.svh
        Vls8_coverage.svh
        Vls16_coverage.svh
        Vls32_coverage.svh
        Vls64_coverage.svh
        Vf16_coverage.svh
        Vf32_coverage.svh
        Vf64_coverage.svh
      priv
        ExceptionsV_coverage.svh
        ZicsrV_coverage.svh
        SsstrictV_coverage.svh
tests
    rv32
        Vx8
            vadd.vv.S
            vadd.vx.S
            vadd.vi.S
            vsub.vv.S
            ...
        Vx16
            vadd.vv.S
            ...
        Vx32
            vadd.vv.S
            ...
        Vx64
            vadd.vv.S
            ...
        Vls8
            vle8.v.S
            vle16.v.S
            vle32.v.S
            vle64.v.S
            vlseg2e8.v.S
            ...
        Vls16
            vle8.v.S
            ...
        Vls32
            vle8.v.S
            ...
        Vls64
            vle8.v.S
            ...
        Vf16
            vfadd.vv.S
            vfadd.vf.S
            vfwadd.vv.S
            vfsub.vv.S
            ...
        Vf32
            vfadd.vv.S
            ...
        Vf64
            vfadd.vv.S
            ...
    rv64
        Vx8
        Vx16
        Vx32
        Vx64
        Vls8
        Vls16
        Vls32
        Vls64
        Vf16
        Vf32
        Vf64
    priv
        ExceptionsV.S
        ZicsrV.S
        SsstrictV.S
----

When an instruction's EEW is not a supported SEW, the coverage files and tests exclude the instruction from testing.  For example, vwadd.vv is not supported when SEW=32 and ELEN = 32 because it cannot widen to 64 bits.

The tests also account for unsupported register group overlap.  For example, a widening add vwadd.wv v0, v2, v2 is unspported because the source registers cannot be read with different EEWs.  On the other hand vwadd.vv v0, v1, v8 with LMUL=1 is supported even though the destination vd=v0 widens to write [v0-v1], which overlaps with vs2=v1.  The tests exercise all supported overlaps, but do not attempt any unsupported overlaps because the behavior is reserved and unpredictable.

==== Vector Configuration Parameters

The coverpoints and tests are parameterized by the minimum supported element width SEW~MIN~ and the maximum supported element width ELEN.  The coverpoints and tests exclude unsupported edge cases, such as widening to more than ELEN or using LMUL=1/8 with ELEN=32 but SEW~MIN~=8.

==== Vector Coverpoints

Running long vectors is computationally expensive, so only a subset of vectors tests run on mult-element vectors.  Coverpoints for source and destination registers, edge values, etc. run on a vector length of vl = 1.

<<t-vector-coverpoints>> defines the coverpoints used in vector instructions.  Unless otherwise specified, each coverpoint uses vector length vl=1 and length multiplier LMUL=1, no mask (vm=1), and vstart=0. Hence, they act on exactly one vector element. For such coverpoints, instructions that require a mask use v0=0.

[[t-vector-coverpoints]]
.Vector Coverpoint Definitions
[cols="2,1,5" options=header]
[%AUTOWIDTH]
|===
|Coverpoint|# Bins|Definition
3+^|Coverpoints acting on single element vl=1
|cp_vd|32|All vector destination registers vd=0-31
|cp_vs2|32|All vector source registers vs2=0-31
|cp_vs1|32|All vector source registers vs1=0-31
|cp_vs3|32|All vector source registers vs3=0-31
|cp_rs1|32|All scalar registers rs1=0-31
|cp_rs2|32|All scalar registers rs2=0-31
|cp_imm_5bit|32|Signed immediate values -16 to +15
|cmp_rs1_rs2|32|rs1 and rs2 are same register ID
|cmp_vd_vs2|32|vd and vs2 are same register ID
|cmp_vd_vs1|32|vd and vs1 are same register ID
|cmp_vs2_vs1|32|vs2 and vs1 are same register ID
|cmp_vs3_vs2|32|vs3 and vs2 are the same register ID
|cmp_vd_vs1_vs2|32|vd and vs1 and vs2 are same register ID
|cp_rs1_edges|9|0, 1, 2, -1, -2, most negative, most negative+1, most positive, most positive-1
|cp_rs2_edges|5|0, 1, 2, -1, -2 (for strided vector load/store)
|cp_fs1_edges|20|0, -1, -smallest subnorm, -inf, 1, 1+ulp, 0.5, 1.5, 2, 4, pi, 2^emax, largest normal, smallest normal, largest subnormal, subnormal with leading 1 in fraction, infinity, canonical quite NaN, noncanonical quiet NaN, signaling NaN with payload of 1
|cp_vs2_edges|9 or 20|see cp_rs1_edges or cp_fs1_edges
|cp_vs1_edges|9 or 20|see cp_rs1_edges
|cr_vs2_vs1_edges|9^2 or 20^2|Cross-product of edges of vs2 and vs1
|cr_vs2_rs1_edges|9*9|Cross-product of edges of vs2 and rs1
|cr_vs2_fs1_edges|20*20|Cross-product of edges of vs2 and fs1
|cr_vs2_imm_edges|9*9|Cross-product of edges of vs2 and imm={0, 1, 2, 14, 15, -1, -2, -15,-16}
|cr_vxrm_vs2_vs1_edges|9*9*4|Cross-product of edges of vs2 and vs1 with vector rounding mode={rod, rdn, rne, rnu}
|cr_vxrm_vs2_rs1_edges|9*9*4|See cr_vxrm_vs2_vs1_edges
|cr_vxrm_vs2_imm_edges|9*9*4|See cr_vxrm_vs2_vs1_edges
|cp_csr_frm|5*10|Floating-point rounding mode={rdn, rmm, rne, rtz, rup} with 10 random inputs per mode
|cp_csr_fflags|5*2|Floating-point sets and clears all applicable flags
3+^|Coverpoints acting on multiple elements vl â‰  1
|cp_masking_edges|5|Mask edge cases v0=all 1s, all 0s, random, first VLMAX-1 ones, first VLMAX/2+1 ones; vl=VLMAX, vm=1 to mask, vma = random, vta = 0
|cr_vl_lmul|7*3|Cross legal combinations of LMUL={1/2/4/8/f2/f4/f8} and vl={1, random, VLMAX}, while randomizing v0 mask value, vm, vta, vma.
|cr_vtype_agnostic|4|Cross vta={0/1} and vma={0/1}. Random legal LMUL, random legal vl, vm=1, v0=random mask
|cp_vxsat|2|vxsat={0, 1}.  Hit by cr_vs2_vs1_edges so no tests needed.
|cp_vl_0|1|vl=0.  LMUL=1, no mask, vma=0, vta=1
|===

As with other unprivileged testplans, an x in the spreadsheet indicates to use the coverpoint.  Other values in the spreadsheet indicate a variant of the coverpoint:

* nv0: Do not include v0 in the coverpoint.  For example, cp_vd_nv0 means that the destination register vd does not include v0.
* emul2: Only exercise even-numbered registers.  For example cp_vs2_emul2 uses vs2={v0, v2, v4, ...v30}.  For edge values, emul2 means the edge value is twice the width of SEW.
* emul4/8: Similar to emul2
* emulf2, emulf4, emulf8: edge values are 1/2, 1/4, or 1/8 the width of SEW.  Used in extension instructions such as vsext.vf2.
* u: Treat immediate as unsigned 0 to 31 rather than signed -16 to +15. For edge values, {0, 1, 2, 15, 16, 30, 31}.
* eew1/mm: Mask instructions with 1-bit elements such as vmand.mm use at least vl=8 to operate on multi-bit masks.
* wv: vs2 is double-width and uses emul2 for its edge values.  vs1 is normal width.
* wred: vs1 is double-width and uses emul2 for its edge values.  vs2 is normal width.
* wx: vs2 is double-width and uses emul2 for its edge values.  rs1 is normal width.
* wi/wiu: vs2 is double-width and uses emul2 for its edge values.  immediate is 5 bit signed or unsigned.
* lmul4max/emul4max: maximum LMUL/EMUL is 4 instead of 8.  vwadd.vv uses lmul4max because it cannot accept LMUL=8 widened to 16.  vlseg2e8.v uses emul4max because the number of segments * EMUL cannot exceed 8.
* lmul2max/lmul1max/emul2max/emul1max: see lmul4max
* lte30/.../lte24: Register number is less than or equal to 30, ..., 24.  Used for segmented load/store so segments won't overflow the register file.
* ls_e{8/16/32/64}: load/store edges with EEW=8,...,64.  Used to convert strided loads from elements to bytes.
* ls: load/store edges instead of integer edges: vs2={0, random < 2*VLMAX}.  rs2= {1, 2, -1, -2, 0}
* f: floating-point edges instead of integer edges: ***

*** discuss special cases

The coverpoints for each vector instruction are given in the following sections.

==== Vx

The Vx testplan is the same for SEW={8, 16, 32, 64}.  Each SEW has its own coverage file (e.g. Vx8_coverages.svh) independent of XLEN, as well as tests that depend on XLEN (e.g. rv32/Vx8/vadd.vx.S).

[[t-Vx-coverpoints]]
.Vx Instruction Coverpoints
include::{testplansdir}/Vx.adoc[]

==== Vls

[[t-Vls-coverpoints]]
.Vls Instruction Coverpoints
include::{testplansdir}/Vls.adoc[]

==== Vf
[[t-Vf-coverpoints]]
.Vf Instruction Coverpoints
include::{testplansdir}/Vf.adoc[]

==== Zvfh Vector Half-Precision Floating-Point Extension

Half-precision vector floating-point is part of the Zvfh and Zvfhmin extensions, not the base V extension.  Nevertheless, Zvfh tests are in the same directory structure as V, under Vf16. Zvfh uses Vf16 <<t-Vf-coverpoints>> to exercise all floating-point instructions with SEW=16.

==== Zvfhmin Half-Precision Conversions

Zvfhmin only exercises the widening and narrowing conversions: `vfwcvt.f.f.v` and `vfncvt.f.f.w`.
[[t-Zvfhmin-coverpoints]]
.Zvfhmin Instruction Coverpoints
,===
//include::{testplansdir}/Zvfhmin.adoc[]
,===

==== ZfaZvfh Half-Precision Load Immediate

When Zfa and Zvfh are both implemented, RISC-V provides a `fli.h` instruction (<<t-ZfaZvfh-coverpoints>>) even if full Zfh is not supported.

[[t-ZfaZvfh-coverpoints]]
.ZfaZvfh Instruction Coverpoints
include::{testplansdir}/ZfaZvfh.adoc[]

==== Zvfbfmin BF16 Conversions

[[t-Zvfbfmin-coverpoints]]
.Zvfbfmin Instruction Coverpoints
,===
//include::{testplansdir}/Zvfbfmin.adoc[]
,===

==== Zvfbfwma BF16 MAC

[[t-Zvfbfwma-coverpoints]]
.Zvfbfwma Instruction Coverpoints
,===
//include::{testplansdir}/Zvfbfwma.adoc[]
,===

=== Zvb* Vector Bit Manipulation Extension

Vector bit manipulation extensions include Zvbb and Zvbc.

==== Zvbb Vector Basic Bit Manipulation Extension
[[t-Zvbb-coverpoints]]
.Zvbb Instruction Coverpoints
,===
// include::{testplansdir}/Zvbb.adoc[]
,===

==== Zvbc Vector Caryless Multiplication Extension

[[t-Zvbc-coverpoints]]
.Zvbc Instruction Coverpoints
,===
// include::{testplansdir}/Zvbc.adoc[]
,===

=== Zvk* Vector Cryptography Extension

There are several Zvk* vector cryptography extensions.  Zvks ShangMi extensions are not yet supported.

==== Zvkb Vector Crypto Bit Manipulation Extension

[[t-Zvkb-coverpoints]]
.Zvkb Instruction Coverpoints
,===
// include::{testplansdir}/Zvkb.adoc[]
,===

==== Zvkg Vector Crypto Galois Field Extension

[[t-Zvkg-coverpoints]]
.Zvkg Instruction Coverpoints
,===
// include::{testplansdir}/Zvkg.adoc[]
,===


==== Zvkned Vector NIST Encryption and Decryption

[[t-Zvkned-coverpoints]]
.Zvkned Instruction Coverpoints
,===
// include::{testplansdir}/Zvkned.adoc[]
,===


==== Zvknh{a/b} Vector NIST Hashing

<<t-Zvknh-coverpoints>> lists the vector hashing instructions.  These apply to both Zknha and Zknhb.

[[t-Zvknh-coverpoints]]
.Zvknh Instruction Coverpoints
,===
// include::{testplansdir}/Zvknh.adoc[]
,===
