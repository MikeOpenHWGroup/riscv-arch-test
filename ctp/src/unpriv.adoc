
== Unprivileged Test Plan

Unprivileged tests exercise every instruction using every applicable source and destination register, and reasonable architectural edge values of sources.  They are intended for certification, not verification. For example, they do not test all difficult floating-point cases.

The unprivileged test plan is written to be easily reviewed by a human, and to be automatically converted to machine-readable coverpoints and tests.
It is defined with spreadsheets in comma-separated value (CSV) format.

=== Unprivileged Tests

Every bin in every coverpoint is associated with a specific test footnote:[cp_asm_count is an exception, just counting the number of times the instruction was executed]. Unprivileged tests sweep some feature under test (such as the destination register rd) while randomizing all applicable register IDs and source values (including values to be loaded from memory).  For example, the unprivileged test for the cp_rd coverpoint of the add instruction contains 32 add instructions, using the 32 different choices of rd.  The rs1 and rs2 register numbers and values are selected randomly. <<Appendix A: Examples>> gives examples of unprivileged coverpoints and tests meeting these requirements and the coverpoints of <<t-I-coverpoints>> for the `add` instruction.  Each test is self-checking, checking the destination register value against one provided by a reference model.  Certain tests also test other state such as stores or floating-point flags, as described in those sections.

[NOTE]
====
The random values are preferably selected in a deterministic way so that regenerating tests use the same random values where possible, minimizing differences between tests.  This can be done by seeding the random number generator with a has of the instruction and coverpoint name.
====

Unprivileged tests are designed to never trap. Their results are independent of the privilege mode in which they are run, so they generally are run only in machine mode.  They generally involve no privileged instructions, except that floating-point and vector tests turn on the mstatus.{FS/VS} bits to enable these extensions.

=== Unprivileged Coverpoints

The coverpoints in <<t-unprivileged-coverpoints>> are used in most of the unprivileged test plans in subsequent sections.

[[t-unprivileged-coverpoints]]
.Coverpoint Definitions
[cols="3,1,10" options=header]
[%AUTOWIDTH]
|===
|Coverpoint|Bins|Definition
3+^|Basic Coverpoints
|cp_asm_count|1|Number of times the instruction is executed in the test, must be greater than 0.
|cp_rs1|32|The rs1 register number used in the instruction.
|cp_rs2|32|The rs2 register number used in the instruction.
|cp_rd|32|The rd register number used in the instruction.
|cp_rs1_edges|16|Edge values for rs1 (see <<t-integer-edge-definitions>>).
|cp_rs2_edges|16|Edge values for rs2 (see <<t-integer-edge-definitions>>).
|cp_imm_edges|16|Edge values for 12-bit immediates (see <<t-immediate-edge-definitions>>).
|cr_rs1_imm_edges|16*20|Cross-product of rs1 and 12-bit immediate edges (see <<t-immediate-edge-definitions>>).
|cr_rs1_rs2_edges|16*16|Cross-product of rs1 and rs2 edges, used for instructions with two source registers.
|cmp_rs1_rs2|32|The rs1 and rs2 registers have the same register number.
|cmp_rd_rs1|32|The rd register has the same register number as the rs1 register.
|cmp_rd_rs2|32|The rd register has the same register number as the rs2 register.
|cmp_rd_rs1_rs2|32|The rd register has the same register number as both the rs1 and rs2 registers.
|cp_offset|2|A branch or jalr instruction has a positive and negative offset.
|cp_uimm|`XLEN`|Exercise all XLEN unsigned immediate values, such as shift amounts.
|cp_align|â‰¤ 8|Alignment of naturally-aligned sub-doubleword load/store operand within doubleword
|cp_gpr_hazard|4|General-purpose register hazard detection: RAW, WAR, WAW, and no hazard.
3+^|Coverpoints for Compressed Instructions
|cp_rs1p|8|The rs1 register number used in compressed instructions supporting x8-x15.
|cp_rs2p|8|The rs2 register number used in compressed instructions supporting x8-x15.
|cp_rdp|8|The rd register number used in compressed instructions supporting x8-x15.
|cp_fdp|8|The fd register number used in compressed floating-point instructions supporting x8-x15.
|cp_fs2p|8|The fs2 register number used in compressed floating-point instructions supporting x8-x15.
|cp_imm_mul|8|7-bit immediate that is a multiple of 4 (for word-sized load/store instructions).
3+^|Coverpoints for Floating-Point Instructions
|cp_fs1|32|The fs1 register number used in the instruction.
|cp_fs2|32|The fs2 register number used in the instruction.
|cp_fs3|32|The fs3 register number used in the instruction.
|cp_fd|32|The fd register number used in the instruction.
|cp_fs1_edges|26|Edge values for fs1 (see <<t-fp-edge-definitions>>)
|cp_fs2_edges|26|Edge values for fs2 (see <<t-fp-edge-definitions>>)
|cp_fs3_edges|26|Edge values for fs3 (see <<t-fp-edge-definitions>>)
|cmp_fd_fs1|32|The fd register has the same register number as the fs1 register.
|cmp_fd_fs2|32|The fd register has the same register number as the fs2 register.
|cmp_fd_fs3|32|The fd register has the same register number as the fs3 register.
|cp_frm|5|The floating-point rounding mode used in the instruction: rne, rdn, rup, rtz, rmm, dyn.
|cp_csr_fflags|10|The instruction sets the {NV, DZ, OF, UF, NX} flags in the fflags CSR.
|cp_csr_frm|6|Dynamic rounding mode in the frm CSR: rne, rdn, rup, rtz, rmm, illegal
|cr_fs1_fs2_edges|26*26|Cross product of edges of fs1 and fs2 registers.
|cr_fs1_fs3_edges|26*26|Cross product of edges of fs1 and fs3 registers.
|cp_fclass|10|All 10 fclass classes.
|cp_NaNBox|1|Upper bits of NaN-boxed value are all 1s
|cp_fs1_badNB|12|The fs1 register contains an incorrectly-NaN-boxed lower-precision value.
|cp_fs2_badNB|12|The fs2 register contains an incorrectly-NaN-boxed lower-precision value.
|cp_fs3_badNB|12|The fs3 register contains an incorrectly-NaN-boxed lower-precision value.
|cp_fpr_hazard|4|Floating-point register hazard detection: RAW, WAR, WAW, and no hazard.
3+^|Miscellaneous Coverpoints
|cp_bs|4|Byte select field for 32-bit AES instructions
|cp_rnum|11|Round nummber for AES instructions
|cp_sc|2|Store conditional instruction has a success and failure case.
|===

Notes:

* These coverpoints are adapted from the Imperas https://github.com/riscv-verification/riscvISACOV[riscvISACOV] functional coverage project.

* Register number is a 5-bit ID (e.g. x7), while register value is an `XLEN`-sized number.

* Most coverpoints typically have 32 bins because they exercise all 32 integer registers.

* Cross-products exercise all combinations of two or more coverpoints. They can have a large number of bins.

* Each of these coverpoints can optionally have a modifer appended.  For example, cp_rs1_nx0 is a modified version of cp_rs1, covering all 31 rs1 register numbers excluding x0.  It is used for load/store/jalr instructions that can't rely on address 0 specified by x0 being legal. Modifiers are defined in the extensions that they apply to.

* The cmp_* and cp_*_hazard coverpoints occupy the fuzzy land at the edge of certification and verification.  They are included because they are easy.

* The riscvISACOV test plan had cmp_rd_{rs1/rs2}_eqval coverpoints that compare if rd and one of the sources have the same value.  These are generally hit by the cr_rs1_rs2_edges tests, so they don't add interesting additional coverage and were dropped.  riscvISACOV also had cp_{rs1/rs2/rd}_toggle tests that checked if each bit changed from 1 to 0 and vice versa.  This is trivially exercised by providing all 0s followed by all 1s followed by al 0s again, so they were dropped.

[[t-integer-edge-definitions]]
.Integer Edge Case Definitions
[options=header]
|===
|Bin|RV32|RV64
|zero    |`00000000000000000000000000000000`|`0000000000000000000000000000000000000000000000000000000000000000`
|one     |`00000000000000000000000000000001`|`0000000000000000000000000000000000000000000000000000000000000001`
|two     |`00000000000000000000000000000010`|`0000000000000000000000000000000000000000000000000000000000000010`
|min     |`10000000000000000000000000000000`|`1000000000000000000000000000000000000000000000000000000000000000`
|minp1   |`10000000000000000000000000000001`|`1000000000000000000000000000000000000000000000000000000000000001`
|max     |`01111111111111111111111111111111`|`0111111111111111111111111111111111111111111111111111111111111111`
|maxm1   |`01111111111111111111111111111110`|`0111111111111111111111111111111111111111111111111111111111111110`
|ones    |`11111111111111111111111111111111`|`1111111111111111111111111111111111111111111111111111111111111111`
|onesm1  |`11111111111111111111111111111110`|`1111111111111111111111111111111111111111111111111111111111111110`
|walkeodd|`10101010101010101010101010101010`|`1010101010101010101010101010101010101010101010101010101010101010`
|walkeven|`01010101010101010101010101010101`|`0101010101010101010101010101010101010101010101010101010101010101`
|random  |`01???????????????????????????010`|`01???????????????????????????????????????????????????????????010`
|Wmax    |n/a|`0000000000000000000000000000000011111111111111111111111111111111`
|Wmaxm1  |n/a|`0000000000000000000000000000000011111111111111111111111111111110`
|Wmaxp1  |n/a|`0000000000000000000000000000000100000000000000000000000000000000`
|Wmaxp2  |n/a|`0000000000000000000000000000000100000000000000000000000000000001`
|===

[[t-immediate-edge-definitions]]
.Immediate Edge Case Definitions (12-bit)
[options=header]
[%autowidth]
|===
|Bin|12-bit Signed Value
|zero|0
|p0|1
|p1|2
|three|3
|p2|4
|p3|8
|p4|16
|p5|32
|p6|64
|p7|128
|p8|256
|p9|512
|hm1|1023
|p10|1024
|max|2047
|min|-2048
|minp1|-2047
|onesm1|-2
|ones|-1
|randomp|1795
|===

[[t-fp-edge-definitions]]
.Floating-Point Edge Case Definitions
[options=header]
|===
|Bin|Half|Float|Double
|pos0|`0000`|`00000000`|`0000000000000000`
|neg0|`8000`|`80000000`|`8000000000000000`
|pos1|`3C00`|`3F800000`|`3FF0000000000000`
|neg1|`BC00`|`BF800000`|`BFF0000000000000`
|pos1p5|`3E00`|`3F000000`|`3FE0000000000000`
|neg1p5|`BE00`|`BF000000`|`BFE0000000000000`
|pos2|`4000`|`40000000`|`4000000000000000`
|neg2|`C000`|`C0000000`|`C000000000000000`
|posminnorm|`0400`|`00800000`|`0010000000000000`
|negminnorm|`8400`|`80800000`|`8010000000000000`
|posmaxnorm|`7BFF`|`7F7FFFFF`|`7FEFFFFFFFFFFFFF`
|negmaxnorm|`FBFF`|`FF7FFFFF`|`FFEFFFFFFFFFFFFF`
|posmax_subnorm|`03FF`|`007FFFFF`|`000FFFFFFFFFFFFF`
|negmax_subnorm|`83FF`|`807FFFFF`|`800FFFFFFFFFFFFF`
|posmid_subnorm|`0200`|`00400000`|`0008000000000000`
|negmid_subnorm|`8200`|`80400000`|`8008000000000000`
|posmin_subnorm|`0001`|`00000001`|`0000000000000001`
|negmin_subnorm|`8001`|`80000001`|`8000000000000001`
|posinfinity|`7C00`|`7F800000`|`7FF0000000000000`
|neginfinity|`FC00`|`FF800000`|`FFF0000000000000`
|posQNaN|`7E00`-`7FFF`|`7FC00000`-`7FFFFFFF`|`7FF8000000000000`-`7FFFFFFFFFFFFFFF`
|posSNaN|`7C01`-`7DFF`|`7F800001`-`7FBFFFFF`|`7FF0000000000001`-`7FF7FFFFFFFFFFFF`
|negQNaN|`FE00`-`FFFF`|`FFC00000`-`FFFFFFFF`|`FFF8000000000000`-`FFFFFFFFFFFFFFFF`
|negSNaN|`FC01`-`FDFF`|`FF800001`-`FFBFFFFF`|`FFF0000000000001`-`FFF7FFFFFFFFFFFF`
|posrandom|`58B4`|`7ef8654f`|`3FF58B4C00000000`
|negrandom|`C93A`|`813d9ab0`|`A6E895993737426C`
|===


[NOTE]
====
The register edge cases are selected to include extreme values and their immediate neighbors.  They also include walking 1s and a random number to exercise intermediate values.  RV64 adds edge casess near the 32-bit boundary to stress W-type instructions.  Immediate edge cases exercise each bit of the immediate, extreme values, and one random intermediate value.
====

include::i.adoc[]
include::m.adoc[]
include::c.adoc[]
include::a.adoc[]
include::f.adoc[]
include::b.adoc[]
include::k.adoc[]
include::zi.adoc[]
include::v.adoc[]
include::unprivmisc23.adoc[]
include::unprivmisc.adoc[]
include::e.adoc[]
